# -*- coding: utf-8 -*-
"""Taylor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o2cvSfZnJHk7X9fvG6l8LbvHfOBkYjZC
"""

#Se importa paqueteria math y decimal
import math as m
from decimal import Decimal
#Definimos la clase que realizara nuestro cálculo

"""
1 punto
También hay comentarios en el otro archivo

"""
"""
No se pidió una clase, de hecho sólo era una función con una única tarea, por lo que no tiene sentido modelarlo
como una clase.

Pero bueno, suponiendo que lo modelan como una clase, falta el método constructor muy importante.
"""
class Calculo:
 
#Condiciones del angulo
  def Tangulo(angulo):
    nAngulo = angulo
    """
    Falta el caso de menor que -360 (que se resuelve con un abs()) en el angulo.
    De cualquier forma aunque si se reduce a un ángulo menor que 360 no neceariamente es el más cercano a 0°
    por ejemplo 719° se reduciría a 359°, que sería lo mismo equivalente a  -1° y ese es el más cercano a 0°.
    """
    if angulo >= 360:
      nAngulo = angulo-360
      Tangulo(nAngulo)
    elif angulo < 0:
      nAngulo = nAngulo+360
      Tangulo(nAngulo)
    return nAngulo

#Aproximación del senx con un E ≤ 0.000001
  def E(Sk,Sk1):
    """
    No hemos visto excepciones para usar esta estructura, aquí podían simplemente usar un if
    """
    try:
      e = m.abs((Sk-Sk1)/Sk1)
    except:
      e = 1.1
    return e
#Se define la funcion seno dada la serie de Taylor, solo introduciendo la formula aun sin la suma
  def fun(sen,k,x):
    nsen = 0.0
    denom = 0
    num = 0
    extra = 0.0
    num = Decimal(m.pow(-1,k))
    denom = Decimal(m.factorial((2*k)+1))
    extra = m.pow(x,((2*k)+1))
    nsen =(float(num/denom)*extra)+sen
    return nsen


#Inicializamos los valores de 
  def SenoTaylor(grados,error=0.000001):
  #Esta parte convierte a radianes segu lo solicitado
    x = m.radians(Tangulo(grados))
    k = 0
    sen = 0.0
    Sk = 0.0
    Sk1 = 0.0
    Er = 10
#Gracias a la función while podemos iterar la suma para hace crear completamente el calculo  
    while Er > error:
      sen = fun(sen,k,x)
      k = k + 1
      Sk = Sk1 +sen
      Er = E(Sk,Sk1)
      Sk1 = Sk
    return sen
  #print("El sin de 39° es: ", m.sin(39))
  #print("El sin de 39° es: ", m.sin(m.radians(39))) Ambos de la paqueteria math se ejecutan muy rapidamente 
  #print("El sin de 39° es: ", SenoTaylor(39,0.0001)) El nuestro le toma tiempo realizar todo el proceso
